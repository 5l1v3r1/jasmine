# 数据结构
#算法&机器学习

### hashtable实现
有一个非常大的数组来存放value值，  计算hashtable的value值

### hash算法
对16进行取模，然后将值存在list中

index = value % 16
先将数据根据hash算法存放在table中，然后在查找时计算散列值
* 用数组加链表来解决冲突
* 确定hash函数

# 链表

### 链表的原理
通过一个temp节点，让他指向不同的对象，然后他虽然指向那个对象，但是他可以修改那个对象的值

在程序中的每个节点的表示，都是一个引用，指向对象所在的物理内存空间。

对一个对象的实际操作是通过引用来进行的

引用是可以换的，如果一个对象的引用为0就自动进行垃圾回收机制

### 转置

#### 1
让第一个节点指向空，第二个节点指向第一个节点，第三个节点指向第二个节点....

用一个temp来记录当前节点
让当前节点指向reverseNode
reverseNode的值初始为None,
然后当前节点赋值给reverseNode,当前节点后移一位，让当前节点的下个节点指向reverseNode,也就是当前节点。
完成转置

while(currentNode)
temp=currentNode
currentNode=currentNode->next
temp.next=ReverseNode
ReverseNode=temp

### 链表转置的递归实现
一直调用反转函数，直到最后一个节点
NodeList * reverse(NodeList *p){

if p==Null || p .next==NULL
p=head
return p;

else :
p1==reverse(*p)
p=p1.next
p.next=Null
return p;

#### 2
让第一个节点指向第三个节点，tempNode保存第二个节点，第二个节点指向第一个节点，然后第三个节点再指向第二个节点

依次添加在第一个节点的尾部b

链表转置的方法， 将left right作为缓冲，将当前节点的下一个元素缓存起来放在right中，将 当前节点指向left,(也就是他的上一个节点)
然后把当前节点放在left中，当前节点往后移一个
重复这个过程，所有节点都会指向他前面的那个节点了，也就是放在left中的
1->2->3->4
right=left=null
current=1
right=2
2->left
left=1

current=2
right=2 left=1
right=3
2->1
left=current=2

current=3
right=4 left=2->1
3->2->1
left=current=3
current=right=4

### 单链表去重

### 链表和数组的比较
链表的内存区域不是连续的

数组的内存区域是连续的

#### 数组
查找速度快，随机访问性强

插入和删除效率低下，不能动态扩展，内存要求高

链表:

插入和删除都是O(1)的

# 树

### 二叉树
完全二叉树
叶子节点只可能在最大的两层上出现

* 度
顶点数等于所有度数+1

### 二叉搜索树 binary tree
左子树节点小于根节点，小于右子树节点
左右子树也是二叉搜索树

没有重复的点

从小到大输出，应该是左中右 中序遍历

2 .前序遍历   根左右
中序遍历  左根右
后序遍历    左右根

### b树
多路搜索树，用于数据库中

通过降低树的深度来减少查找的频率

降低深度的方法:

M序b树:

* 任何节点最多有M个子节点
* 任何非叶节点至少含有M/2个节点
* 根节点至少还有两个子节点
* b树只支持随机检索，b+树既支持随机检索也支持顺序检索

### N个节点的M序b树的高度
第2层至少有两个点，

第3层每个点至少还有M/2个点。  2*M/2

第4次 2*(m/2)^2个点

第5层 2*(M/2)^3

第L层 2*(m/2)^(l-2)

l-1=log（m-2） *(N+1)/2+1

### b+树
所有的叶子节点包含了全部的关键字以及关键字指向文件的指针

1. 所有叶子节点的关键字按照大小排序
2. 相邻叶子节点按照顺序链接
3. b+树是有序的

b+树的读写效率更高

##### b+树有利于对数据库的扫描

###### 只需要遍历叶子节点就可以解决对全部关键字信息的扫描

##### 查询效率更稳定

### 霍夫曼树

## 堆
根节点最大的堆叫做最大堆

根节点最小的堆为最小堆

插入 O(logn)

创建O(n)


# 图

#### dfs 和bfs
判断图是否稀疏的方法

* 动态规划，动态规划的原理

dfs 时间复杂度

| 数据结构 | dfs    | bfs    | dijkstra    | Bellman-ford |
| -------- | ------ | ------ | ----------- | ------------ |
| 邻接矩阵 | O(V2)  | O(V2)  | O(v2)       | O(VE)        |
| 邻接链表 | O(V+E) | O(V+E) |             | O(VE)        |
| 二叉堆   |        |        | O(V+E)logv) |              |

### Bellman-ford

# 算法和基础知识

### 中缀表达式

### 1+((2+3)×4)-5 转换为后缀表达式

* 后缀表达式从左往右
	* 123+4×+5-
* 前缀表达式从右往左
	* 5432+×

- - - -
### 二分查找(根据元素找到下标)
首先是排好序的
根据元素找到下标:
middle=0+size;
if a[index]>a[middle]:
low=middle+1
else:
high=middle-1

- - - -
### 链表
插入时间复杂度:O(1)
删除时间复杂度O(n)
删除尾部元素 需要知道链表长度

### 折半查找的平均次数
每次扫描全数组，找到中间的数，然后把数组分为两部分继续，
平均次数就是每个数扫描的次数全部加起来，然后除以数的总个数,即可

1,2,3,4,5,6,7,8,9,10
第一次找到6，6搜索了一次
1,2,3,4,5  ,7,8,9,10 两次
12,45,    78,9 10 3次
2  5 ,  8  10 4次

计算方法:
将全部数字画作完全二叉树，然后每层节点数*书的高度加起来，除数目

## kmp算法
next数组计算
1235123
next: 0,0,2,2

next的数组的定义: the length of the longest proper prefix that matches a proper suffix  前缀匹配后缀的中最长value值。
在aba中   前缀有a,ab,后缀有 a,ba  aba不算的，因为没有意义。
所以以aba为例，他的前缀和后缀最大匹配长度应该为1
next数组的定义就出来了:  当前index的子字符串最大前缀和后缀的匹配长度。


所以kmp在遍历出现第一个不匹配时。找之前匹配字符串的最大匹配长度，比如
bacbababaabcbab
    |||||
    abababca
当出现不匹配时，找ababa的最大匹配长度。根据上面的定义。最大匹配长度应该是 3。子字符串应该向前跳 5-3的长度。这样可以省掉一些重复的匹配过程。为什么说是5-3呢: ababa 匹配长度是3.在出现不匹配时，后缀的aba已经匹配过了，是相同的(因为第六个才是第一个不匹配的。)所以前缀aba不需要再重复匹配了。只需将前缀的aba移到后缀的位置上来就可以了。将子字符串向右移动两位。即:
bacbababaabcbab
    xx|||
      abababca

即可继续匹配，当出现不匹配的情况时，重复之前步骤即可。
目的: 找出子字符串是否在长字符串中存在。
伪代码:
string : 长字符串
substr : 子字符串
i=0,j=0
begin:
	next=calculate_partial_table()

	while j<len(string):
		if substr[i]==string[j]:
			i++; j++;
		else:
			i=i-next[i-1]

		if i==len(substr)-1:
				return true
	return false

calculate_partial_table:
	i=0
	str=‘abcded’

	for i in str:


# 栈
逆波兰数

数据进栈出栈

# 基础知识

### 反码
正数的反码等于他本身

负数的反码等于各项取反，符号位除外，第一位表示符号位

10010->11101

### 补码
正数的补码等于他本身，负数的补码等于反码+1

10010->11101->11110

### 用到的算法总结

## o(1) 时间内维持一个长度为n的最大list
维持一个有序队列，每进来一个元素,先和第一个进行比较，如果大往后移动，如果小和之前的元素进行替换。

直接.sort()+字符串切片

## 原地算法

空间复杂度固定的算法，为O(1)的算法。
